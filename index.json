[{"content":"","date":"18 July 2025","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"","date":"18 July 2025","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":"","date":"18 July 2025","externalUrl":null,"permalink":"/","section":"Learn Something New","summary":"","title":"Learn Something New","type":"page"},{"content":" TL;DR If you don’t feel like reading my ramblings, the Github repository with the final state of the docker-compose.yaml file, as well as the necessary configuration files can be found here.\nIf you\u0026rsquo;re anything like me, you like to tinker with everything technology-related. You\u0026rsquo;re also weary of fingerprinting and tracking of your online habits, and would like to set up a way of routing your self-hosted services like PiHole through a VPN, while keeping everything easily configurable and transferable. If you\u0026rsquo;re nodding your head right now, you\u0026rsquo;ve come to the right place.\nContainers # Containers, in this context, are used as a reference to any containerization platform that performs OS-level virtualization through multiple userspace container instances. The benefit of using containers is that we are able to encapsulate the software and its dependencies into a single package that can then be deployed in different environments. Configuration of these \u0026ldquo;containers\u0026rdquo; should be done through files, making a deployment replicable and transferable across different environments.\nWireGuard # Like the older OpenVPN protocol, WireGuard is a protocol and software implementation for establishing virtual private networks (VPNs). It excels in its lower overhead relative to older protocols, its high performance and its easy configuration. The protocol was released in the Linux 5.6 kernel, which we will be making use of its kernel modules inside a container by exposing /lib/modules. The standard software implementation of the WireGuard protocol is also called WireGuard, which may cause some confusion, but all we need to know is that it the application that allows us to interact with the wireguard kernel module. Most of the time we\u0026rsquo;ll be using wg-quick, the utility to establish and stop WireGuard VPN connections.\nLinuxserver.io # Linuxserver.io is a community and community-maintained list of docker container images who follow a unified best-practices approach to their container images, while maintaining small container sizes and some helpful added-on functionality that we will be making use of for implementing the kill switch. They maintain a WireGuard (userspace utilities) image that we will use as the outbound VPN container through which all other containers will connect to the internet. Using Linuxserver.io\u0026rsquo;s /custom-cont-init.d folder we can add a startup script that will be run before the VPN connection is made. The GitHub image repository can be found here.\nVPN # It\u0026rsquo;s now time to set up our own VPN client with a correctly configured kill switch and add some other images to use it. The first step is to get your own VPN provider, I have used Mullvad VPN for a few years as my VPN provider of choice and have never had any issues with them. They run a no-log VPN service, their clients are open source, and they helped fund WireGuard\u0026rsquo;s development, so it\u0026rsquo;s a pretty easy choice for me. Most importantly, in this case, is that you can generate a WireGuard client configuration that you can then use as the configuration for your Linuxserver.io WireGuard container.\nPutting it all together # OK, we\u0026rsquo;re ready to create our stack. Following Linuxserver.io WireGuard container\u0026rsquo;s instructions, we can generate our first docker-compose.yaml.\n### DOCKER-COMPOSE.YAML FILE ### services: wireguard: image: lscr.io/linuxserver/wireguard:latest container_name: wireguard hostname: wireguard cap_add: - NET_ADMIN - SYS_MODULE environment: - PUID=${PUID} - PGID=${PGID} - TZ=${TZ} volumes: - ${CONFIG_DIR}/wireguard:/config - ${CONFIG_DIR}/wireguard_startup:/custom-cont-init.d:ro - /lib/modules:/lib/modules sysctls: - net.ipv4.conf.all.src_valid_mark=1 restart: unless-stopped The variables in the docker-compose.yaml file are saved in the .env file, which get automatically used by docker-compose:\n### .ENV FILE ### # ======== user ======== PUID=1000 PGID=1000 TZ=Australia/Sydney # ======== directories ======== CONFIG_DIR=/home/jmartins/wireguard-stack/configs In order to use WireGuard we need to drop a WireGuard configuration file in the container\u0026rsquo;s /config folder that we map to our ${CONFIG_DIR}/wireguard folder. Generating this file on Mullvad\u0026rsquo;s website is fairly easy, and in this case we\u0026rsquo;re only using an IPv4-only configuration since we want to manually control the ports available from outside the host. The generated configuration should look something like this:\n[Interface] PrivateKey = [REDACTED] Address = 10.64.114.74/32 DNS = 10.64.0.1 [Peer] PublicKey = a6oniBujlUXqOmv5Hst0v8xCqidy7O4JcN8Q6YRM5Hk= AllowedIPs = 0.0.0.0/0 Endpoint = 89.44.10.178:51820 If we run the docker-compose up -d command, the default network will now be created, along with the docker container. We can test the spun up container by executing docker exec -it wireguard /bin/bash to get access to a bash session inside the running container. Here, we can run regular network tests like curling Mullvad\u0026rsquo;s connection check URLand pinging IP addresses:\nroot@wireguard:/# curl https://am.i.mullvad.net/connected You are connected to Mullvad (server au14-wireguard). Your IP address is 89.44.10.183 root@wireguard:/# ping 1.1.1.1 PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data. 64 bytes from 1.1.1.1: icmp_seq=1 ttl=58 time=3.84 ms 64 bytes from 1.1.1.1: icmp_seq=2 ttl=58 time=3.82 ms 64 bytes from 1.1.1.1: icmp_seq=3 ttl=58 time=3.29 ms ^C --- 1.1.1.1 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2004ms rtt min/avg/max/mdev = 3.293/3.651/3.838/0.253 ms You are now ready to start routing connections through this container by setting their network mode as \u0026quot;service:wireguard\u0026quot;. But before we get to that, lets take care of the network kill switch, which will prevent requests to flow outside the network if for some reason the VPN connection is dropped.\nWireGuard Kill Switch # Generating the wg0.conf file on Mullvad\u0026rsquo;s website allows us to add a kill switch to the wireguard configuration. These are nothing but shell commands that run PostUp and PreDown, up and down referring to wg-quick\u0026rsquo;s verbs for starting and stopping the VPN client connection.\nCreating a WireGuard configuration with a kill switch yields the following file:\n[Interface] PrivateKey = [REDACTED] Address = 10.64.23.84/32,fc00:bbbb:bbbb:bb01::1:1753/128 DNS = 10.64.0.1 PostUp = iptables -I OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT \u0026amp;\u0026amp; ip6tables -I OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT PreDown = iptables -D OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT \u0026amp;\u0026amp; ip6tables -D OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT [Peer] PublicKey = pu22RCPeJCeiDIE7a1XtWvmv3BdgPp8ugF6AyntW8xU= AllowedIPs = 0.0.0.0/0,::0/0 Endpoint = 89.44.10.114:51820 The kill switch commands consist of iptables rules blocking all outbound traffic in the container and allowing only traffic to flow through the wireguard network adapter.\nUsing the downloaded configuration file, we can see that stopping the connection will remove the iptables rules, allowing traffic to flow out:\nroot@wireguard:/# curl https://am.i.mullvad.net/connected You are connected to Mullvad (server au14-wireguard). Your IP address is 89.44.10.183 root@wireguard:/# ping 1.1.1.1 PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data. 64 bytes from 1.1.1.1: icmp_seq=1 ttl=58 time=3.28 ms 64 bytes from 1.1.1.1: icmp_seq=2 ttl=58 time=11.6 ms 64 bytes from 1.1.1.1: icmp_seq=3 ttl=58 time=4.08 ms ^C --- 1.1.1.1 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2004ms rtt min/avg/max/mdev = 3.278/6.304/11.559/3.730 ms root@wireguard:/# wg-quick down wg0 Warning: `/config/wg0.conf\u0026#39; is world accessible [#] iptables -D OUTPUT ! -o wg0 -m mark ! --mark $(wg show wg0 fwmark) -m addrtype ! --dst-type LOCAL -j REJECT \u0026amp;\u0026amp; ip6tables -D OUTPUT ! -o wg0 -m mark ! --mark $(wg show wg0 fwmark) -m addrtype ! --dst-type LOCAL -j REJECT [#] ip -4 rule delete table 51820 [#] ip -4 rule delete table main suppress_prefixlength 0 [#] ip -6 rule delete table 51820 [#] ip -6 rule delete table main suppress_prefixlength 0 [#] ip link delete dev wg0 [#] resolvconf -d wg0 -f [#] iptables-restore -n [#] ip6tables-restore -n root@wireguard:/# curl https://am.i.mullvad.net/connected You are not connected to Mullvad. Your IP address is 161.8.193.91 root@wireguard:/# ping 1.1.1.1 PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data. 64 bytes from 1.1.1.1: icmp_seq=1 ttl=57 time=2.66 ms 64 bytes from 1.1.1.1: icmp_seq=2 ttl=57 time=3.87 ms 64 bytes from 1.1.1.1: icmp_seq=3 ttl=57 time=3.30 ms ^C --- 1.1.1.1 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2003ms rtt min/avg/max/mdev = 2.657/3.276/3.872/0.496 ms Note on DNS resolution vs outbound traffic # There is a possibility that you may confuse lack of DNS resolution with blocked outbound traffic if your IP block overlaps with your container network subnet. This is unlikely to happen and that would mean that DNS resolution was blocked regardless of iptables rules, but it also means that you may be mistaken on the state of your container network rules. This could, for example, allow through traffic that does not depend on DNS, like say a peer-to-peer connection.\nThe solution is then to remove the PreDown directive, leading to an outbound blocked connection state whenever the connection is brought down.\nroot@wireguard:/# wg-quick down wg0 Warning: `/config/wg0.conf\u0026#39; is world accessible [#] ip -4 rule delete table 51820 [#] ip -4 rule delete table main suppress_prefixlength 0 [#] ip -6 rule delete table 51820 [#] ip -6 rule delete table main suppress_prefixlength 0 [#] ip link delete dev wg0 [#] resolvconf -d wg0 -f [#] iptables-restore -n [#] ip6tables-restore -n root@wireguard:/# curl https://am.i.mullvad.net/connected curl: (6) Could not resolve host: am.i.mullvad.net root@wireguard:/# ping 1.1.1.1 PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data. From 10.0.0.2 icmp_seq=1 Destination Port Unreachable ping: sendmsg: Operation not permitted From 10.0.0.2 icmp_seq=2 Destination Port Unreachable ping: sendmsg: Operation not permitted From 10.0.0.2 icmp_seq=3 Destination Port Unreachable ping: sendmsg: Operation not permitted ^C --- 1.1.1.1 ping statistics --- 3 packets transmitted, 0 received, +3 errors, 100% packet loss, time 2032ms A less curious/paranoid person would at this point be happy with the kill switch functionality. However, I am neither of those. Since the kill switch depends on a successful parsing of the wireguard configuration file, an issue presents itself with the way the container handles failure. In short, if there are any issues parsing the configuration file, the container will not connect to the VPN server and continue allowing outbound network calls to flow through. Silently.\nIn a borrowed term from mechanical engineering into application/network security, this is a case of fail open, where a failure on startup will lead to a permissive state. If we purposely create this error, we can see the issue.\n[Interface] PrivateKey = [REDACTED] Address # This malformed configuration leads to an error DNS = 10.64.0.1 PostUp = iptables -I OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT \u0026amp;\u0026amp; ip6tables -I OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT [Peer] PublicKey = a6oniBujlUXqOmv5Hst0v8xCqidy7O4JcN8Q6YRM5Hk= AllowedIPs = 0.0.0.0/0 Endpoint = 89.44.10.178:51820 Docker log of the container startup:\n... wireguard | Warning: `/config/wg0.conf\u0026#39; is world accessible wireguard | [#] ip link add wg0 type wireguard wireguard | [#] wg setconf wg0 /dev/fd/63 wireguard | [#] ip -4 address add Address dev wg0 wireguard | Error: inet prefix is expected rather than \u0026#34;Address\u0026#34;. wireguard | [#] ip link delete dev wg0 ... We can then see that we are able to make outbound requests from the container, as if we were connected and blocking requests outside the VPN tunnel:\nroot@wireguard:/# curl https://am.i.mullvad.net/connected You are not connected to Mullvad. Your IP address is X.X.X.X If we would like to make this a fail close system, a solution is to decouple the iptables outbound rules setting from the WireGuard execution. Making use of the Linuxserver container addons we can add a script that will be run on container startup and will block outbound connections the same way as PostUp does.\n#!/bin/bash echo \u0026#34;**** IPTABLES BLOCK ****\u0026#34; iptables -I OUTPUT ! -o wg0 -m mark ! --mark 0xca6c -m addrtype ! --dst-type LOCAL -j REJECT ip6tables -I OUTPUT ! -o wg0 -m mark ! --mark 0xca6c -m addrtype ! --dst-type LOCAL -j REJECT wg-quick automatically adds a mark on all encrypted packets it sends1, with the value of this mark being the port it is configured to connect through. If you use the default 51820 port, then the iptables rules matching 0xca6c will work, as this is the hexadecimal representation of decimal 51820. If you use any other port, then you must change this script to the correct hexadecimal value, and if you forget to do this, no traffic will be allowed to flow outbound from the container. Again, failing closed.\nroot@wireguard:/# curl https://am.i.mullvad.net/connected curl: (6) Could not resolve host: am.i.mullvad.net root@wireguard:/# ping 1.1.1.1 PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data. From 10.0.0.2 icmp_seq=1 Destination Port Unreachable ping: sendmsg: Operation not permitted From 10.0.0.2 icmp_seq=2 Destination Port Unreachable ping: sendmsg: Operation not permitted From 10.0.0.2 icmp_seq=3 Destination Port Unreachable ping: sendmsg: Operation not permitted ^C --- 1.1.1.1 ping statistics --- 3 packets transmitted, 0 received, +3 errors, 100% packet loss, time 2032ms Note: In the default Mullvad wireguard configuration, the packet mark is obtained by running wg show %i fwmark, where %i is the wireguard interface name as expanded in wg-quick2. This won\u0026rsquo;t work here, as the startup script will run before the wireguard interface is created, and thus we instead hardcode the mark to 0xca6c instead, ensuring that, regardless of the wireguard connection state, only packets marked with 0xca6c will be allowed to egress.\nVPN consumers # Now that we have the container ready and we\u0026rsquo;re correctly stopping requests we don\u0026rsquo;t want to proceed, we can configure other containerised images that we will route through the VPN container exclusively. This will both route all their network requests through the WireGuard container as well as make them subject to its outbound network rules containing the kill switch. For this, we\u0026rsquo;ll use docker-compose\u0026rsquo;s network_mode3 option, as suggested in this Linuxserver.io article4, allowing a container to make use of a different container\u0026rsquo;s network stack, in this case the WireGuard container.\nAs an example consumer application, we\u0026rsquo;re using here the thespeedtest-tracker, which will periodically, every ten minutes, run a speed test in its network interface and store the result. Since we\u0026rsquo;re forcing the container to use the wireguard container\u0026rsquo;s network stack, its iptables rules will apply and all traffic will flow through the wireguard interface.\n### DOCKER-COMPOSE.YAML FILE ### services: wireguard: image: lscr.io/linuxserver/wireguard:latest container_name: wireguard hostname: wireguard cap_add: - NET_ADMIN - SYS_MODULE environment: - PUID=${PUID} - PGID=${PGID} - TZ=${TZ} volumes: - ${CONFIG_DIR}/wireguard:/config - ${CONFIG_DIR}/wireguard_startup:/custom-cont-init.d:ro - /lib/modules:/lib/modules ports: - 8080:80 sysctls: - net.ipv4.conf.all.src_valid_mark=1 healthcheck: test: ping -c 1 1.1.1.1 || exit 1 interval: 2s start_period: 10s start_interval: 2s timeout: 5s retries: 3 restart: unless-stopped speedtest-tracker: image: lscr.io/linuxserver/speedtest-tracker:latest restart: unless-stopped container_name: speedtest-tracker network_mode: service:wireguard environment: - PUID=${PUID} - PGID=${PGID} - TZ=${TZ} - APP_KEY=${APP_KEY} - DB_CONNECTION=sqlite - SPEEDTEST_SCHEDULE=\u0026#34;*/10 * * * *\u0026#34; - DISPLAY_TIMEZONE=${TZ} volumes: - ${CONFIG_DIR}/speedtest-tracker:/config healthcheck: test: curl -fSs http://localhost/api/healthcheck | jq -r .message || exit 1 interval: 10s retries: 3 start_period: 30s timeout: 10s depends_on: wireguard: condition: service_healthy As you may notice, since the network is managed by the wireguard container, in order to expose the port that speedtest-tracker serves its web interface in, port 80, this port forward needs to be controlled on the wireguard ports directive instead. Here, we\u0026rsquo;ve decided to port forward that port to port 8080, which we\u0026rsquo;ll use to access the speedtest-tracker web UI.\nFinally, like described on the linuxserver.io guide4:\nBut it doesn\u0026rsquo;t end there. Even though the port is mapped, once the tunnel is up, it won\u0026rsquo;t respond to any requests coming from the host as it\u0026rsquo;s configured to send all outgoing connections through the tunnel.\nThis means we need to add the routing rules to allow the host to access the container\u0026rsquo;s web interface. In the article, this is done as part of the wg-quick configuration file, but since we are using a shell script to set the kill switch rules, we can add the routing rules there as well. The following lines will allow the host to access the speedtest-tracker web interface:\n#!/bin/bash set -e echo \u0026#34;**** Adding iptables rules ****\u0026#34; HOMENET=192.168.0.0/16 HOMENET2=10.0.0.0/8 HOMENET3=172.16.0.0/12 iptables -I OUTPUT -d $HOMENET -j ACCEPT iptables -A OUTPUT -d $HOMENET2 -j ACCEPT iptables -A OUTPUT -d $HOMENET3 -j ACCEPT # Kill switch iptables -A OUTPUT ! -o wg0 -m mark ! --mark 0xca6c -m addrtype ! --dst-type LOCAL -j REJECT ip6tables -I OUTPUT ! -o wg0 -m mark ! --mark 0xca6c -m addrtype ! --dst-type LOCAL -j REJECT echo \u0026#34;**** Successfully added iptables rules ****\u0026#34; Here, the various HOMENETs are the local network IP ranges usually used in home networks, as defined in RFC-19185. We add the iptables rules to allow traffic to flow out to the local network, including the web UI of the speedtest-tracker container, which is now accessible at http://localhost:8080.\nConclusion # In this article, we have seen how to set up a WireGuard VPN container that can be used as a kill switch for other containers. We have also seen how to set up a consumer container that uses the WireGuard container\u0026rsquo;s network stack and how to expose its web interface to the host. The kill switch is implemented using iptables rules that block all outbound traffic unless it is going through the WireGuard interface, and we have ensured that the system fails closed by decoupling the kill switch from the WireGuard connection setup.\nThis was never intended to be a series of articles, but since it took me so long to finally write it down, my local wireguard stack has evolved quite a bit, including running the WireGuard container as both a client and a server, allowing clients to connect to it over the internet, routing their traffic through the Mullvad VPN connection and giving access to the containers running on the host. Expect a follow-up article on this topic in the future.\nWg-quick Default Firewall Rules\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nwg-quick manpage\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDocker compose network_mode docs\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLinuxserver.io Wireguard guide\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRFC-1918\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"18 July 2025","externalUrl":null,"permalink":"/posts/wireguard-docker-killswitch/","section":"","summary":"","title":"Routing Docker Containers Through a WireGuard VPN Container with Kill Switch","type":"posts"},{"content":"","date":"18 July 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"18 July 2025","externalUrl":null,"permalink":"/tags/vpn/","section":"Tags","summary":"","title":"VPN","type":"tags"},{"content":"","date":"18 July 2025","externalUrl":null,"permalink":"/tags/wireguard/","section":"Tags","summary":"","title":"WireGuard","type":"tags"},{"content":" Python-based static webpage # Previously, my web presence was composed of a static page built using staticjinja, an HTML5 UP template, and my own json parsing logic to build the different elements displayed. Back when I made it I had little experience with Javascript and no wish or need to update it continually as one does with a blog.1 It looked something like this:\nIt worked well as I didn\u0026rsquo;t have the need to update it often, but perhaps leading to it being usually very out-of-date as I changed projects and workplaces. Adding to this, the advent — or should I say return? — of blogging and developer diaries made me want to start my own blog. This would be where I share what I learn along the way, some tricks and tips on Python and development strategies that seem to work for me.\nJavascript static site generators # While Medium seems to be the platform of choice for these kinds of blogging, I\u0026rsquo;m a proponent of free open source software and of learning-by-doing, so this was a good opportunity to learn some more Javascript, React and Gatsby, an open source static site generator with good Markdown support.\nMaking it mine # I have always had an obsessive relationship with tinkering and making my digital experiences as close to my liking as possible. A good example is Dark Reader, an open source browser extension that \u0026ldquo;inverts brightness of web pages and aims to reduce eyestrain while you browse the web\u0026rdquo;, which I currently use for handling pages that don\u0026rsquo;t offer a native dark mode.\nThis website is based on Lumen, a Gatsby starter blog with a minimalistic and pleasing design. It does not support a dark mode out of the box, making its implementation an interesting learning experience. It also seems to be a request from people using the starter blog, so it\u0026rsquo;s a good opportunity to help out.\nAfter some research — figuring out the quality of developer blog posts has become a skill in itself — I had a few good ideas on how to do this. Ananya\u0026rsquo;s article2 on dev.to was a great starting point, especially since most other articles don\u0026rsquo;t suggest CSS custom properties (also called variables) for implementing dark mode.\nThe most common approach seems to be defining an alternative dark mode global \u0026lt;body\u0026gt; class and using Javascript before the body renders to edit its class to the dark mode explicitly. Since Lumen already makes use of Sass, I went with a mixed approach, keeping Sass variables in the different components and assigning to them the CSS custom properties.\nThis has its drawbacks too, as we can\u0026rsquo;t use Sass color module functions, but the very limited number of colors and page types of the template allows for pre-setting all the colors we will use. It also has its benefits, since we can directly use CSS attribute selectors and HMTL5\u0026rsquo;s data-* global attributes. We can use an attribute selector dependent on our data-* attribute, changing the color variables depending on which theme data attribute we select.\nMedia queries and setting a mode # Media Queries allow authors to test and query values or features of the user agent or display device, independent of the document being rendered. They are used in the CSS @media rule to conditionally apply styles to a document, and in various other contexts and languages, such as HTML and JavaScript.\n— Media Queries Level 5 specification\nWe\u0026rsquo;re connecting another recent feature of CSS formatting, media queries and, more specifically, the prefers-color-scheme media query that informs the browser of the client\u0026rsquo;s OS dark/light mode preference. With this I can infer the reader\u0026rsquo;s preference for a dark or light mode and use that preference to style the page accordingly.\nconst mql = window.matchMedia(\u0026#39;(prefers-color-scheme: dark)\u0026#39;); const hasMediaQueryPreference = typeof mql.matches === \u0026#39;boolean\u0026#39;; if (hasMediaQueryPreference \u0026amp;\u0026amp; mql.matches === true) { document.documentElement.dataset.theme = \u0026#39;dark\u0026#39;; } else { document.documentElement.dataset.theme = \u0026#39;light\u0026#39; } mql should hold a boolean, indicating if the user\u0026rsquo;s OS color preference is dark mode. Like I mentioned before, I\u0026rsquo;m using data-* attributes, which means that we can use the dataset object of documentElement. Subsequently, I set my alternative CSS selector to use these data-* attribute:\n// Colors, using css variables :root { // Based on One Light: https://github.com/atom/one-light-syntax/blob/master/styles/colors.less --bg-color: rgb(231, 230, 223); --base: rgb(11, 23, 82); --primary: rgb(134, 69, 28); --secondary: rgba(11, 23, 82, 70%); --gray: hsl(230, 23%, 23%); --gray-border: hsl(230, 77%, 13%); } [data-theme=\u0026#34;dark\u0026#34;] { // Based on One Dark: https://github.com/atom/atom/blob/master/packages/one-dark-syntax/styles/colors.less --bg-color: hsl(220, 13%, 18%); --base: hsl(219, 14%, 71%); // mono-1 --primary: hsl( 29, 54%, 61%); // orange-1 --secondary: hsl(220, 9%, 55%); // mono-2 --gray-border: hsl(220, 10%, 40%); // mono-3 --gray: hsl(0, 0%, 100%); // white } As discussed before, depending on the root data attribute, the page will either display the default CSS colors, or the dark mode colors.\nFlash of Unstyled Content # The flash of unstyled content (FOUC) is a fairly annoying consequence of sequential DOM building, where a browser will display HTML without having fully loaded its CSS. It is especially noticeable on dark/light mode pages when the default flashing page mode is different from the expected OS color mode, and getting around this issue is fairly easy with Gatsby.\nIn order to avoid this we\u0026rsquo;ll load and set the preferred media mode (dark or light) using Gatsby\u0026rsquo;s setPreBodyComponents function in its server side render options. When using this specific starter blog, editing the gatsby/on-render-body.js file is where these changes should be placed, since this file is referenced by the Gatsby server side rendering file, gastby-ssr.js.\nconst applyDarkModeFunc = ` (function() { const mode = localStorage.getItem(\u0026#39;theme\u0026#39;); if (mode !== null \u0026amp;\u0026amp; [\u0026#39;light\u0026#39;, \u0026#39;dark\u0026#39;].includes(mode)) { document.documentElement.dataset.theme = mode; return; } const mql = window.matchMedia(\u0026#39;(prefers-color-scheme: dark)\u0026#39;); const hasMediaQueryPreference = typeof mql.matches === \u0026#39;boolean\u0026#39;; if (hasMediaQueryPreference \u0026amp;\u0026amp; mql.matches === true) { document.documentElement.dataset.theme = \u0026#39;dark\u0026#39;; } else { document.documentElement.dataset.theme = \u0026#39;light\u0026#39; } })(); `; const onRenderBody = ({ setPreBodyComponents }) =\u0026gt; { setPreBodyComponents([ React.createElement(\u0026#39;script\u0026#39;, { dangerouslySetInnerHTML: { __html: applyDarkModeFunc, }, }), ]); }; As you can see, before drawing the page body we check for a stored preference in localStorage and return if there is one. If not, we check the OS\u0026rsquo;s preferred color scheme and set te page theme accordingly.\nReact Hooks and Toggler # Finally, we need to create a button to change between dark and light mode. For this we\u0026rsquo;re using React\u0026rsquo;s functional programming hooks, making use of useState and useEffect. The first will be used to create a theme state variable and setter. Using this theme variable, we\u0026rsquo;ll register it as a dependency of the useEffect-triggered function, which will be run whenever the theme changes.\nWhenever the button is pressed and the toggleTheme function runs, the theme variable is changed to the appropriate new value by triggering our anonymous function:\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; import styles from \u0026#39;./DarkModeToggler.module.scss\u0026#39;; function ThemeToggler() { const initTheme = document.documentElement.dataset.theme; const [theme, setTheme] = useState(initTheme); useEffect(() =\u0026gt; { localStorage.setItem(\u0026#39;theme\u0026#39;, theme); document.documentElement.dataset.theme = theme; }, [theme]); function toggleTheme() { const newTheme = theme === \u0026#39;dark\u0026#39; ? \u0026#39;light\u0026#39; : \u0026#39;dark\u0026#39;; setTheme(newTheme); } return ( \u0026lt;div className={styles[\u0026#39;toggler\u0026#39;]}\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; onClick={() =\u0026gt; toggleTheme()} hidden={true} /\u0026gt;{`${theme} mode`} \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; ); } export default ThemeToggler; Finishing steps # With all of this in place we are pretty much done! Small details like the medium-style zoom provided by gatsby-remark-images-medium-zoom can be configured in the gatsby-config.js page. I\u0026rsquo;d recommend using a CSS attribute (as a string) as the backgroung option, which will make it work with the dark/light mode settings too!\nThis is all I needed to do to make this work, feel free to replicate and modify it if you\u0026rsquo;re looking for the same functionality. I don\u0026rsquo;t have any comments section on this blog (on purpose), so feel free to open an issue on this page\u0026rsquo;s repo or message me through LinkedIn.\nPost Script 1 # While building and deploying I found a issue with SSR and the React component I built. The issue is that the browser DOM methods aren\u0026rsquo;t available when building on server side, but following Gatsby\u0026rsquo;s documentation we can work around the problem. To not have to add another dependency I decided to use React component lazy loading and check for the availability of the DOM methods, following the workaround 4 in the linked page.\nThese changes were introduced in the component that loads that offending component, Sidebar.js, and building now works correctly, as well as in development mode.\nThe code is still available under the gh-page-staticjinja-based branch backing this repo.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nArticle by Ananya Neogi.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"31 May 2021","externalUrl":null,"permalink":"/posts/dark-mode/","section":"","summary":"","title":"Gatsby, Lumen and Dark Mode","type":"posts"},{"content":"\nMostly little things that I learn here and there, updates seldom and mostly in bursts. ","externalUrl":null,"permalink":"/about/","section":"Learn Something New","summary":"","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]